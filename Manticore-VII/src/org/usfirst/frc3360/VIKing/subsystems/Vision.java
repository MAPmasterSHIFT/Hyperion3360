// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3360.VIKing.subsystems;

import org.usfirst.frc3360.VIKing.RobotMap;
import org.usfirst.frc3360.VIKing.commands.*;
import edu.wpi.first.wpilibj.CANTalon;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;


/**
 *
 */
public class Vision extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    NetworkTable table;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public Vision() {
        table = NetworkTable.getTable("GRIP/myContoursReport");
	}
    
    public double[] visionGetCenterX(){
		double[] defaultValue = new double[0];
		double[] centerX = table.getNumberArray("centerX", defaultValue);
		
		if(centerX.length == 0){
			return new double[]{0};
		}
		else{
			return centerX;
		}
   }
   
   public double[] visionGetCenterY(){
		double[] defaultValue = new double[0];
		double[] centerY = table.getNumberArray("centerY", defaultValue);
	
		if(centerY.length == 0){
			return new double[]{0};
		}
		else{
			return centerY;
		}		
   }
   
   public double[] visionGetWidth(){
		double[] defaultValue = new double[0];
		double[] width = table.getNumberArray("width", defaultValue);
		
		if(width.length == 0){
			return new double[]{0};
		}
		else{
			return width;
		}
   }
   
   public double[] visionGetHeight(){
 		double[] defaultValue = new double[0];
 		double[] height = table.getNumberArray("height", defaultValue);
 		
 		if(height.length == 0){
			return new double[]{0};
		}
		else{
			return height;
		}
   }
   
   public double[] visionGetArea(){
 		double[] defaultValue = new double[0];
 		double[] area = table.getNumberArray("area", defaultValue);
 		
 		if(area.length == 0){
			return new double[]{0};
		}
		else{
			return area;
		}
   }
   
   public double[] visionGetSolidity(){
		double[] defaultValue = new double[0];
		double[] solidity = table.getNumberArray("solidity", defaultValue);
		
		if(solidity.length == 0){
			return new double[]{0};
		}
		else{
			return solidity;
		}
   }
   
   public double visionGetDistanceFeet(){
	   double x;
	   try{
		   x = visionGetCenterY()[targetToAlign()];
	   }
	   catch (Exception e){
		  x = visionGetCenterY()[0];
	   }
	   return (0.0002033*Math.pow(x, 2)) - (0.012*x) + 3.536;
   }
   
   public double visionGetDistanceInches(){
	   return visionGetDistanceFeet()*12;
   }
   
   public double getXDistanceFromTargetInches(){
	   double x = getDeltaX() * visionGetDistanceFeet();
	   return (-0.00001052*Math.pow(x, 2)) + (0.057*x) + 5.649;
   }
   
   public double getDeltaX(){
	   double deltaX = 0;
	   double center = (1*visionGetDistanceFeet())+131;
	   try{
		   deltaX = center-visionGetCenterX()[targetToAlign()];
	   }catch(Exception e){
		   deltaX = center-visionGetCenterX()[0];
	   }
	   
	   return deltaX;
   }
   
   public double getTargetAlignRotationAngle(){
	   double offset = -radToDegres(Math.atan(getXDistanceFromTargetInches()/visionGetDistanceInches()));
	   
	   return offset;

   }
   
   public double depassement(double offset){
	   return (-0.008549*Math.pow(offset, 2)) + (0.626*offset) - 0.596;
   }
   
   public double radToDegres(double rad){
	   return rad*57.2958;
   }
   
   public int targetToAlign(){
	   int x = 0;
	   double[] width = visionGetWidth();
	   double biggerWidth = 0;
	   
	   for(int i=0; i<width.length; i++){
		   if(width[i]>=biggerWidth){
			   biggerWidth = width[i];
			   x = i;
		   }
	   }
	   
	  // System.out.println("TARGET TO ALIGN = "+x);
	   return x;
   }
}

