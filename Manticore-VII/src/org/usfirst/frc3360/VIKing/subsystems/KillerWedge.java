// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3360.VIKing.subsystems;

import org.usfirst.frc3360.VIKing.Robot;
import org.usfirst.frc3360.VIKing.RobotMap;
import org.usfirst.frc3360.VIKing.commands.*;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class KillerWedge extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon angleRMotor = RobotMap.killerWedgeAngleRMotor;
    private final CANTalon angleLMotor = RobotMap.killerWedgeAngleLMotor;
    
    private final Relay aimLight = RobotMap.aimLightRelay;

    /*
    //PID variables
    private final double kP = 9;
    private final double kI = 0.0001;	// old value = 0.00025
    private final double kD = 0.005;	//old value = 0.001
    private final double kF = 0;
    */
    
    
    /*
     * ************************************
     * ********* PID sa coche MTL *********
     * ************************************
     * 
  //PID variables
    private final double kP = 20;
    private final double kI = 0.00025;	// old value = 0.00025
    private final double kD = 0.5;	//old value = 0.001
    private final double kF = 0;
    */
    
  //PID variables
    private final double kP = 20;
    private final double kI = 0.0005;	// old value = 0.00025
    private final double kD = 0.5;	//old value = 0.001
    private final double kF = 0;
    
    //PID positions
    public final double kPosAtFront = 802;
    public final double kPosAtBack = 138;
    public double kPosSafeToLoad = 350;
    //This is main angle
    public final double kPosAtBatter = 465;
    
    
    public final double kPosAtShoot = 455;
    public final double kPosAtScale = 350;
    public final double kPosRange = kPosAtBack - kPosAtFront;
    
    
    
    
    //
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public KillerWedge(){
    	angleLMotor.changeControlMode(TalonControlMode.Position);
    	angleLMotor.setFeedbackDevice(CANTalon.FeedbackDevice.AnalogPot);
    	angleLMotor.setPID(kP, kI, kD, kF, 0, 3, 0);  
    	angleLMotor.enableControl();
    	
    	angleRMotor.changeControlMode(TalonControlMode.Follower);
    	angleRMotor.reverseOutput(false);
    	angleRMotor.set(angleLMotor.getDeviceID());
    	angleRMotor.enableControl();
    }
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	setDefaultCommand(new KillerWedgeManualHandle());
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void setKillerWedgePos(double pos, String from){
    	if(from == "Batter"){
    		pos += batterCorr(); 
    	}
    	else if(from == "Front"){
    		pos += frontCorr();
    	}
    	
    	if(pos>kPosAtFront){
    		pos = kPosAtFront;
    	}
    	else if(pos < kPosAtBack){
    		pos = kPosAtBack;	
    	}
    	//System.out.println("arm angle wanted : " + pos);
    	System.out.println("arm angle : " + angleLMotor.getAnalogInRaw());
    	angleLMotor.set(pos);
    }
    
    
    
    public double getWantedAngle(){
    	double axisVal = -Robot.oi.getCoPilotJoystick().getRawAxis(0);
    	double angleWanted;
    	angleWanted = ((axisVal + 1)/2);
    	angleWanted = angleWanted * kPosRange;
    	angleWanted += kPosAtFront;
    	
    	//System.out.println("wanted angle : " + angleWanted);
    	//System.out.println("Current distance feet : " + Robot.vision.visionGetDistanceFeet());
    	//System.out.println("X distanceFromGoal : " + Robot.vision.getXDistanceFromTargetInches());
    	///System.out.println("TargetAlignRotationAngle : " + Robot.vision.getTargetAlignRotationAngle());
    	return angleWanted;
    }
    public double getCurrentAngle(){
    	return angleLMotor.getAnalogInRaw();
    }
    
    public void setLight(boolean state){
    	if(state){
    	aimLight.set(Relay.Value.kForward);
    	
    	}else{
    		aimLight.set(Relay.Value.kOff);
    	}
    }
    
    public double batterCorr(){
    	double corr = Robot.oi.getCoPilotJoystick().getRawAxis(4)*50;
    	System.out.println("Batter correction : " + corr);
    	return corr;
    	
    }
    
    public double frontCorr(){
    	double corr = Robot.oi.getCoPilotJoystick().getRawAxis(5)*50;
    	System.out.println("Batter correction : " + corr);
    	return corr;
    }
    
  /* public double getShootAngle(){
	   return perfectShootAngle(Robot.vision.visionGetDistanceFeet());
   }
   
   public double perfectShootAngle(double distance){
     //return -0.989*Math.pow(distance, 2) + 16.512*distance + 402.944;
	   return -0.989*Math.pow(distance, 2) + 16.512*distance + 420.944 + (Robot.oi.getCoPilotJoystick().getRawAxis(2) * 25);
	 //return -0.989*Math.pow(distance, 2) + 16.512*distance + 410.944 + (Robot.oi.getCoPilotJoystick().getRawAxis(2) * 50);
   }
   */
}

