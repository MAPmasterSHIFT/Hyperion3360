// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3360.VIKing;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc3360.VIKing.commands.*;
import org.usfirst.frc3360.VIKing.commands.AutoCommands.AutonomousCommand;
import org.usfirst.frc3360.VIKing.commands.AutoCommands.AutonomousDriveWithEncoders;
import org.usfirst.frc3360.VIKing.commands.AutoModes.AutonomousLowBar;
import org.usfirst.frc3360.VIKing.commands.AutoModes.AutonomousLowBarHigh;
import org.usfirst.frc3360.VIKing.commands.AutoModes.AutonomousCrossBD;
import org.usfirst.frc3360.VIKing.commands.AutoModes.AutonomousCrossHigh;
import org.usfirst.frc3360.VIKing.subsystems.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */


public class Robot extends IterativeRobot {

    Command autonomousCommand;
//    SendableChooser defenseChooser;
//    SendableChooser positionChooser;
    BuiltInAccelerometer accelerometerOnBoard;


    public static double HorizontalOffset = 0;
    
    
    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static TankDrive tankDrive;
    public static Intake intake;
    public static Winch winch;
    public static KillerWedge killerWedge;
    public static SuperPunch superPunch;
   // public static Vision vision;
    
    public static boolean isAutonomous = true;
    public static int autoPosition = 2;

   // public static CameraServer server;
    
    public static DigitalInput autoSwitch1 = new DigitalInput(9);    
    public static DigitalInput autoSwitch2 = new DigitalInput(8);
    public static DigitalInput autoSwitch3 = new DigitalInput(7);
    public static DigitalInput autoSwitch4 = new DigitalInput(6);
    public static DigitalInput autoSwitch5 = new DigitalInput(5);
    
   
    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
    RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        tankDrive = new TankDrive();
        intake = new Intake();
        winch = new Winch();
        killerWedge = new KillerWedge();
        superPunch = new SuperPunch();
      //  vision = new Vision();
        

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();
//        defenseChooser = new SendableChooser();
//        positionChooser = new SendableChooser();
//    	defenseChooser.initTable(NetworkTable.getTable("Defense Chooser"));
    	//positionChooser.initTable(NetworkTable.getTable("Position Chooser"));
//    	defenseChooser.addDefault("BD cross", "Cross");

//    	defenseChooser.addObject("Low Bar", "Lowbar");

    	//positionChooser.addDefault("2", 2);
    	//positionChooser.addObject("3", 3);
    	//positionChooser.addObject("4", 4);
    	//positionChooser.addObject("5", 5);
    	
//    	SmartDashboard.putData("Autonomous Defense Chooser", defenseChooser);
    	//SmartDashboard.putData("Autonomous Position Chooser", positionChooser);
    
    
        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        accelerometerOnBoard = new BuiltInAccelerometer();

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        

//        server = CameraServer.getInstance();
//        server.setQuality(50);
//        //the camera name (ex "cam0") can be found through the roborio web interface
//        server.startAutomaticCapture("cam0");
        
       /**
        * AUTONOMOUS CHOOSER
        **/
      //Determine defense position
    	if(!autoSwitch1.get()){
    		autoPosition = 2;
    	}
    	else if(!autoSwitch2.get()){
    		autoPosition = 3;
    	}
    	else if(!autoSwitch3.get()){
    		autoPosition = 4;
    	}
    	else if(!autoSwitch4.get()){
    		autoPosition = 5;
    	}
    	
    	//1&2 On = No HG
    	if(!autoSwitch5.get() && (!autoSwitch1.get() || !autoSwitch2.get() || !autoSwitch3.get() || !autoSwitch4.get())){
    		autonomousCommand = new AutonomousCrossBD(autoPosition);
    		System.out.println("Cross only");
    	}
    	//All off = LowBar auto
    	else if(autoSwitch1.get() && autoSwitch2.get() && autoSwitch3.get() && autoSwitch4.get() && autoSwitch5.get()){
    		
    		autonomousCommand = new AutonomousLowBarHigh();
    		System.out.println("Low bar");
    	}
    	else if(!autoSwitch5.get() && autoSwitch1.get() && autoSwitch2.get() && autoSwitch3.get() && autoSwitch4.get()){
    		autonomousCommand = new AutonomousLowBar();
    	}
    	//Only one On = Cross + HG
    	else{
    		autonomousCommand = new AutonomousCrossHigh(autoPosition);
    		System.out.println("Cross Shoot : " + autoPosition);
    	}

    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    public void disabledInit(){

    }

    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    public void autonomousInit() {
    	
    	isAutonomous = true;
     
    	/*
    	//Determine defense position
    	if(autoSwitch1.get()){
    		autoPosition = 2;
    	}
    	else if(autoSwitch2.get()){
    		autoPosition = 3;
    	}
    	else if(autoSwitch3.get()){
    		autoPosition = 4;
    	}
    	else if(autoSwitch4.get()){
    		autoPosition = 5;
    	}
    	
    	//1&2 On = No HG
    	if(autoSwitch1.get() && autoSwitch2.get()){
    		autonomousCommand = new AutonomousCrossBD(autoPosition);
    	}
    	//All off = LowBar auto
    	else if(!autoSwitch1.get() && !autoSwitch2.get() && !autoSwitch3.get() && !autoSwitch4.get()){
    		
    		autonomousCommand = new AutonomousLowBar();
    	}
    	//Only one On = Cross + HG
    	else{
    		autonomousCommand = new AutonomousCrossHigh(autoPosition);
    	}
    		*/
    	
    	
//    	if(defenseChooser.getSelected() == "Lowbar"){
//    		autonomousCommand = new AutonomousLowBar();
//    		System.out.println("set auto : LowBar");
//    	}else {
//    		autonomousCommand = new AutonomousCrossBD(autoPosition);
//    		System.out.println("set auto : Rough");
//    	}
        

        
        tankDrive.setControlMode(3);
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }

    /**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
           
    }

    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();

        isAutonomous = false;
    	tankDrive.setControlMode(2);
    }

    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
        Scheduler.getInstance().run();
        
       // System.out.println(accelerometerOnBoard.getZ());
        /*if(IsOnObstacle()){
        	System.out.println("OBSTACLE");
        }else{
        	System.out.println("");
        }*/
        
    }

    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() {
        LiveWindow.run();
    } 
    
   
   public boolean IsOnObstacle(){
	   double accelZvalue = accelerometerOnBoard.getZ();
	   
	   // adjust this reference to detect if robot is on obstacle or not
	   if(accelZvalue < 1.4){	
		   return false;		// on flat ground
	   }else{
		   return true;			// on obstacle 
	   }
   }
}
